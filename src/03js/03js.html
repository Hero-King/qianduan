<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

    <div>page</div>

    <script>
        //js中的数据类型有哪些?
        //js中的原始数据类型:number,string,boolean,null,undefined,object
        /*
         * number:数字类型(整数和小数)
         * string:字符串类型(的值一般都是用单引号或者是双引号括起来)  "34"
         * boolean:布尔类型(值只有两个,true(真1),false(假0))
         * null:空类型,值只有一个:null,一个对象指向为空了,此时可以赋值为null
         * undefined:未定义,值只有一个:undefined
         * 什么情况下的结果是undefined
         * 变量声明了,没有赋值,结果是undefined
         * 函数没有明确返回值,如果接收了,结果也是undefined
         * 如果一个变量的结果是undefined和一个数字进行计算,结果:NaN不是一个数字,也没有意义
         * object:对象---->
         *
         * */
        //如何获取这个变量的数据类型是什么? 使用typeof关键字 来获取
        //typeof 的使用的语法
        /*
         * 都可以获取这个变量的数据类型是什么!
         * typeof 变量名
         * typeof(变量名)
         *
         * */
        var num = 10;
        var str = "小白";
        var flag = true;
        var nll = null;
        var undef;
        var obj = new Object();
        //是使用typeof 获取变量的类型  typeof 少null 多function object
        console.log(typeof num); //number
        console.log(typeof str); //string
        console.log(typeof flag); //boolean
        console.log(String(nll)); //是null
        console.log(typeof nll); //不是null 而是object 存储的是对象,只不过没有指向
        console.log(typeof undef); //undefined
        console.log(typeof obj); //object
        console.log(typeof (num));
        //    console.log("10");
        //    console.log(10);
        // 如何准确的判断数据类型
        console.log(Object.prototype.toString.call("1212")) // [object String]
        console.log(Object.prototype.toString.call([])); // 03js.html:56 [object Array]
        console.log(Object.prototype.toString.call({})); // 03js.html:57 [object Object]
        console.log(Object.prototype.toString.call(12)); // [object Number]
        console.log(Object.prototype.toString.call(null)); // [object Null]


        // JS浮点数也是不准确存储的
        /*
        var num ;
        console.log(num+10 == NAN ) false  
        console.log(isNaN(num)) false NaN(not a number不是一个数字,和其他类型比较就是false)
        boolean 类型:
        undefined 表示一个申明了没有赋值的变量,变量只申明时候 var num;
        null是变量的值为空 或者说指向了空  var str = null ; 这个变量是对象类型 释放内存也是用的=null
        
        转Boolean: Boolean()
        转数字: parseInt parseFloat [Number()比前面两个严格]
        转字符串: tostring()  String(10) 
        变量有意思 可以使用toString方法,没有意思不可以使用
        数组里面的数据类型可以是不同的;同时可以使用访问数组的方式设置数组值

        函数--重点
        定义: function 函数名(参数){函数体}  这是函数表达式,会提升,重名覆盖
            匿名函数: function (){}  函数表达式 var aa = function (){} 变量指向函数对象
        调用: 函数名();
        函数名命名规则: 不允许重名; 遵循驼峰命名法
        console.log(sum)会输出函数的代码 函数名就是函数代码; 自调用,申明的时候立即调用,一次性的: (函数代码)()是不是和aa()一样 如(function(){})()
        自调用一次性的  解决命名函数冲突问题
        不写var 也可以定义变量,但是是隐式的全局变量
        typeOf  结果是function  

        函数可以当做参数使用,如果一个函数是参数,那我们就称作他为回调函数;
        函数可以当做返回值使用,
        作用域: 全局变量如果页面不关闭,就会一直存在占用内存;使用var 定义的变量,可以在外边访问德到相当于全局变量(除了函数里面定义的)  隐式全局变量,省略var 即使定义在函数里面,运行完成也不会消失
        预解析: 变量的申明和函数申明都会提前到当前所在的作用域最上面 var num  function aa(){}但是变量的赋值不会提前
        
        对象
        创建:常见的有三种方式
        1.调用系统构造函数 new Object()
        2.自定义函数,工厂模式 function person(name.age){avr obj = new Object();obj.name = name return obj}
                自定义构造函数 function Person(name.age){this.name=name;this.age=age} var per = new Person("aa",12)
        
        3.自面量 var obj ={}
        设置对象属性的两种方式  obj.name = "wang" 或者obj["name"]="wang" 
            obj.play()  或者obj["play"]()
         JSON也是对象
         遍历对象原始方法:  for (var key in object){}
         普通类型作为参数传递,传递的是值;
         引用类型作为参数传递,传递的是地址

        JS中三种对象: 内置对象(Math Date String Array Object)  自定义对象 BOM对象
        date对象获取小时分钟毫秒 可能会有一位数的情况  hour<10? '0'+ hour : hour

        JS字符串: 字符串就是多个字符组成的数组;  不可变性(更改字符串的值在内存中会新增一块空间并重新指向新的空间)
        String对象
        var str1 = '你好'  没有堆空间
        var str2 = new String ('你好')   堆空间

         */
        // alert('都是弟弟');
        (function () {
            console.log('我是函数自调用,永远不会被冲突');
        })();

        f();
        var num = 20;

        function f() {
            console.log(num); //undefined 因为函数申明提前,可以调用函数;其次变量申明到函数内最上面,并没有赋值
            var num = 10;
        }

        // 自己实现系统的math.max方法
        function MyMath() {
            this.getMax = function () {
                let max = arguments[0];
                for (let i = 0; i < arguments.length; i++) {
                    if (max < arguments[i]) max = arguments[i];
                }
                return max;
            }
        }
        var myMath = new MyMath();
        console.log(myMath.getMax(1, 2, 5, 50, 23, -10));

        // 随机产生一个十六进制的颜色  #3412ff
        function getColor() {
            // 随机生成0-255的数字 
            let ran = parseInt(Math.random() * 256);
            let red = ran.toString(16); //将数字转换成16进制
            ran = parseInt(Math.random() * 256);
            let green = ran.toString(16); //将数字转换成16进制
            ran = parseInt(Math.random() * 256);
            let blue = ran.toString(16); //将数字转换成16进制
            return '#' + red + green + blue; //等等
        }
        console.log(getColor()); //例如#d85fd7

        // console.log(new Date().getMonth()); //老外的日期是从0 开始的0-11月

        // 封装函数返回指定格式的日期: 2019年12月7日 11:12:13  获取当前时间
        function getDate() {
            let date = new Date();
            return date.getFullYear() + '年' + (date.getMonth() + 1) + '月' + date.getDate() + '日' + ' ' + date
                .getHours() + '时' + date.getMinutes() + '分' + date.getSeconds() + '秒';
        };
        console.log(getDate());

        function Person(name) {
            this.name = name
        }

        // 普通方式使用原型： 
        let aa = new Person("小灰灰")
        console.log(aa.name);
        Person.prototype.alertMessage = function () {
            // alert("我是原型链加上的")
            console.log("我是原型链加上的");
        }
        aa.alertMessage();
        console.log(aa.__proto__ === Person.prototype, "原型") // true
        //我们知道 Person = new Function   
        console.log(Person.__proto__ === Function.prototype) // true

        // 静态方法定义和调用
        Person.static = () => console.log("Person static method");
        Person.static();

        // jquery学习参见git下面的jquery项目

        // 深浅拷贝[1]
        function deepClone(obj, endObj) {
            let type = typeof obj;
            if (type === "string" || type === "number" || obj === null || type === "undefined") {
                return obj
            }
            let objNew = endObj || {};
            for (let i in obj) {
                if (obj.hasOwnProperty(i)) {
                    if (typeof obj[i] === "object") { // [] {}
                        objNew[i] = obj[i].constructor === Array ? [] : {};
                        deepClone(obj[i], objNew[i])
                    } else {
                        objNew[i] = obj[i]
                    }
                }

            }
            return objNew
        }
        let objTemp = {
            name: "wang",
            age: {
                age: 12,
                arr: ["arr"]
            }
        }
        let clone = deepClone(objTemp)
        objTemp.age.age = "12345";
        console.log("深拷贝后源数据美变化吗", clone.age.age == 12)

        // 深浅拷贝[2]
        let clone2 = JSON.parse(JSON.stringify(objTemp))
        clone2["age"].age = "age"
        console.log(objTemp)

        // 感觉也可以
        function deepClone3(obj) {
            if (obj === null) {
                return "null";
            }
            if (obj === undefined) {
                return "undefined";
            }
            let objNew = {};
            for (let i in obj) {
                if (obj.hasOwnProperty(i)) {
                    if (typeof obj[i] === "object") {
                        objNew[i] = deepClone(obj[i])
                    } else {
                        objNew[i] = obj[i]
                    }
                }
            }
            return objNew
        }

        // 特殊类型的转换   NaN 0 undefined null "" 会转换成false
        console.log(undefined == null) // true
        console.log(undefined === null) // false
        console.log(0.1 + 0.2) // 0.300000000004
        console.log((0.1 * 100 + 0.2 * 100) / 100) // 0.3

        // 包装对像
        //  let str = "123"
        // str.length   内部实现：   let str1 = new String(str)     str1.length  str1 =null
        // str.x = 3        str.x 显示 undefined 

        // +法 如果是一般数据类型就处理   如果包含一个引用数据类型 需要先对引用数据调用 valueOf() 如果返回
        // 普通类型 相加即可  不是的话继续调用toString()方法  然后返回值相加
        console.log([] + []); // "" 
        console.log("" + []); // ""
        console.log("" + {}); // "[object Object]"
        console.log({} + {}); // "[object Object][object Object]"
        console.log(+"") // 0


        // 返回的是本地时间， 如果是抢购等  时间需要用后台的  本地时间是可以改变的
        console.log(new Date())

        let url = "https://cn.bing.com/search?q=伟大的&sp=4";
        console.log("encodeUrl", encodeURI(url)); // 会把中文ascall编码
        console.log("encodeURIComponent", encodeURIComponent(url)); // 会把协议等字符也编码

        // DOM树构建过程
        /**
         * 1. 访问server 返回二进制html
         * 2. 翻译二进制文件成 index.html
         * 3. HTMl解析器 解析文件   词法解析(生成document对象)  生成节点Node  生成DOM树
         * 解析过程中，如果遇到link标签，使用browser 进程的网络线程去请求文件 （并行的）
         * 遇到script 标签，默认属性会停止构建dom 执行js文件      async 不停止渲染，下载完成不需要按顺序执行
         * defer  不停止渲染，渲染完成后执行，在domcontentloaded之前执行完 多个defer 会按顺序执行
         * 4. css解析器构建css   每个css文件解析成样式表对象cssstylesheet 包含很多cssrule  在解析词法  生成css树
         * 5. 构建render树 ：  DOM树 + css树
         * 6. 布局layout: 计算每个dom节点的盒子大小和页面的坐标，
         * 7.绘制     重要概念： 回流reflow： 元素属性发生改变且影响布局时（padding height），产生回流，相当于刷新页面
         *                              repaint 重绘  元素属性发生改变且不影响布局时候（背景图片  透明度  字体样式），产生重绘。相当于不刷新页面动态更新
         */

        // 闭包
        function bibao() {
            var index = 0;
            return function () {
                console.log(index++)
            }
        }
        const bibaoitem = bibao()
        bibaoitem() //0
        bibaoitem() //1
        bibaoitem() //2

        // this    局部函数的this是window 
        var mythis = {
            age: 12,
            getage: function () {
                console.log(this.age)
            },
            getget: function () {
                var that = this;
                var bb = function () {
                    console.log(this) // windows
                }
                bb()
                console.log(that, "保存下来的that就是调用函数的对象了") //mythis对象
            }
        }
        mythis.getage() //12
        mythis.getget()

        Function.prototype.mybind = function (obj) {
            var self = this;
            return function () {
                self.apply(obj)
            }
        }

        // html5 拖拽  https://www.cnblogs.com/wenruo/p/10225377.html
        // 设置元素可以拖拽: <div draggable="true">  此区域可拖拉</div>  正常的 div 是不能被拖动的，鼠标点击选择后移动没有效果，需要加  draggable="true" 使得元素可以被拖动。
        // 被拖拽元素的事件：ondragstart，ondragend ondrag 放置元素的事件：ondragenter、ondragover、ondragleave、ondrop 

    </script>
    <style>
        img {
            display: block;
        }
    </style>
</body>

<img src="https://img-blog.csdnimg.cn/img_convert/c27677c78368a4e8d45d0d89aaadbffd.png"
    alt="c27677c78368a4e8d45d0d89aaadbffd.png">
<img src="https://images1.pianshen.com/28/85/85579830a1049af8e7dda9890b6451ec.png" />

</html>