<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script>
        /**
     * 学习使用DOM 文档对象模型
     * 书籍推荐--->无基础  JS王者归来  晋升看JS高级
     * 把整个页面一个HTML文件看成文档 树根对象  所有的标签是对象
     * 每个标签都是一个对象,都是一个元素element
     * 节点Node就是 标签+属性+文本
     * btn.onClick = function(){
     *  alert("哈哈哈")
     *  btn.type = "text";
     *  btn.value="嘎嘎"
     *  this.id = "id1"    这里可以用this 代表事件源 或者说谁调用这个匿名函数  btn按钮  而不是window对象
     * }
     * 
     * script标签的作用  JS代码是从上到下执行的,不能再页面还没有渲染出来的时候去操作某个节点
     * so script的位置要想好写在哪里;
     * html里面标签的属性是没有px的  CSS里面才是的
     * 
        每一个HTML标签都看成元素,在JS中用对象表示,元素的属性都挂在了对象下面
     * 修改标签文本内容  成对的标签  innerText   input输入框内容设置它的value属性
     * 修改超链接的指向  herf属性
     * 获取div1里面的p  还使用document对象吗?? 应该这样document.getElementById("div1").getElementsByTagName("p")
     * JS修改状态 checked属性设置boolean值  disabled  禁用  对于html disabled = "disabled"  可以省略只写disabled   readonly
     * 获取到某个元素.style.backgroundColor  style样式的属性都是将 -  改成 大写字母
     * 获取某个元素,设置给他设置一个样式  强不强   JSDOM操作时候,设置className为某个样式
     * 
     * 超链接默认有点击跳转事件  可以在事件处理函数中return false 结束函数
     * 设置标签中的文本内容,也可以使用textContent属性 但是浏览器打架,低版本的IE不支持textContent
     *                  当然innerText属性低版本的火狐不支持  -->兼容代码
     * 当某个属性在浏览器中不支持,那么返回的数据类型就是undefined 就可以根据这个判断是否兼容然后写兼容带代码 工具JS文件中书写处理函数,然后script标签引入,就可以调用 当然这里是都在window对象下面
     * HTML的标签可以自定义属性,就是直接写<li score="10"   然后这个标签就有了自定义的score属性,但是JS获取到的DOM对象是没有这个属性的 不可以直接.出来的
     * 可以通过使用 getAttribute("score") 方法获取  JS使用setAttribute()设置自定义的属性
     * 懂了吗  也就是说JS代码获取到的元素标签对象身上只有标准属性,标准属性设置,获取可以直接点出来  但是自定义属性点不出来,需要使用提供的方法  removeAttribute移除属性 可以是自定义的也可以是自带的还可以移除样式removeAttribute("class")
     *  
        
     * 
     */
        // document.getElementById()
        // document.getElementsByClassName
        // document.getElementsByName
        // document.getElementsByTagName
        // document.getAttribute()
        // document.setAttribute()
        /**
        * 节点的介绍 Node 包括标签 内容 属性等节点类型  记不记得本子上画的图  属性节点在标签节点左边 文本节点在标签节点下面
           节点的属性: nodeType 1代表标签节点 2 代表属性节点 3文本节点
                       nodeName 节点名字 标签节点---大写的标签名  属性节点---小写的属性名  文本节点---#text
                       nodeValue 节点的值 标签节点---null 属性节点--属性值  文本节点---文本内容
           父节点 parentNode  parentElement  父亲肯定是元素节点或者说标签节点 这两个属性的值是一样的
           子节点 childNodes(回车换行是文本节点算到节点里面  返回NodeList) 和children子元素(子标签 返回的类型是HTMLCollection)不一样  
            第一个子节点  firstChild
            第一个子元素  firstElementChild
            最后一个子节点 lastChild
            最后一个子元素 lastElementChild
            前一个兄弟节点 previousSibling
            前一个兄弟元素 previousElementSibling
            后一个兄弟节点 nextSibling 
            后一个兄弟元素 nextElementSibling 
        */

        /*
        元素创建:  为了提高用户体验, 并不是页面的首次加载完成必须的东西和并不是所有用户都需要看到的东西
            使用元素创建的方式,响应用户
        1. document.write("标签和代码")  缺陷 如果页面加载完成后调用这个方法,会把body标签里面所有内容全部干掉
        2. 对象.innerHtml = "标签和代码"
        3. document.createElement("p")  父亲调用appendChild() 
        代码执行完成这些创建元素的方法后,就可以调用获取节点的方法,获取那些刚创建的节点  
        
        循环创建元素的时候,绑定事件使用函数申明,可以节约内存,提高效率,匿名函数的话会创建很多个
        只创建一个元素-->事件处理啊函数中  有子元素删除,没有则创建
        给同一个元素绑定多个相同事件  getElementBuId("btn1").addEventListener('click',事件处理函数)
        如果是IE8 用attachEvent('onClick',回调)  所有的事件名字本来没有on前缀的  后面微软加上去的 形成传统
        */

        console.log(document.getElementById('div1')); //这里写就是返回了null因为代码从上往下执行,先执行了JS脚本 此时页面没有渲染出来这个节点
    </script>
</head>
<div id="div1">
    <input type="button" value="点我换色" id="btn1">
    <span>121212</span>
    <p>我是P标签</p>
    <span>121212</span>
    <p>我是P标签</p>
    <span>121212</span>
    <p>我是P标签</p>
    <p>　　1、肖申克的救赎</p>
    <p>　　2、阿甘正传</p>
    <p>　　3、盗梦空间</p>
    <p>坦坦尼克号  当幸福来敲门  希特勒名单  教父  星际穿越 罗马假日</p>
</div>
<script>
    console.log(document.getElementById('div1'));
    console.log(document.getElementById('div1').childNodes); //返回NOdeList
    console.log(document.getElementById("div1").children); //返回HTMLCollection
    document.getElementById('btn1').onclick = function () {
        let pelements = document.getElementsByTagName('p');
        for (let index = 0; index < pelements.length; index++) {
            console.log(111);
            const element = pelements[index];
            element.style.backgroundColor = "red"
        }
    }
    // 使用节点的方式  让P标签换背景色
</script>

<body>

</body>

</html>