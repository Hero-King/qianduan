/**
 *  JS 原型  每一个构造函数都有一个属性叫 prototype  是一个对象,可以给他动态添加属性和方法  这些属性和方法对象可以
 * 直接调用
 * 
    自己创建出来的对象有个属性 __proto__ 指向了构造函数的原型对象
    对象的__proto__属性和构造函数中的prototype属性是一个对象
    原型对象中有个属性constructor 指向了构造函数
    原型对象是对象,它的__proto__是object对象,即Object构造函数的原型对象  在往上就是null

    通常我们自己定义的构造函数里面定义一些属性,方法定义到原型对象上面达到节约内存的目的
    Student.prototype = {
         方法
    }
    但是这样导致对象的原型里面缺少constructor属性
    可以在上面添加该属性 constructor: Student
    注意: 想要使用自己定义的构造和原型对象,需要在定义好了原型后在new对象
    给内置对象的原型对象添加属性或者方法只能通过.的方式 Array.prototype.getSum= 不能Array.protorype={}  保护作用
    在原型对象里面  this表示啥?  代表调用这个属性/方法的实例啊  记住了

    体会好面向对象编程
    所有的JS文件命名的变量都是在全局作用域里面的,难免会存在命令冲突的问题.我们可以使用匿名函数自调用的方式降低冲突,但是我们怎么使用
    匿名函数中的重要内容呢? 可以在匿名中 挂载使用的对象到window对象下面
    自调用函数避免结合出错,在函数前面加一个;
    自调用参数常会有 (window,undefined)
      window的作用是使得代码用到的window对象变成参数,参数就可以在压缩代码时候变成单个字母,减少代码体积
      undefined同上,同时 undefined在老版本中可以被重新定义;防止自调用函数中用到被更改的undefined
   定时器里面回调函数的this是window,因为是window执行的代码
    function aa(){}.bind(对象,参数1,参数2)  返回一个函数,里面this指向对象  相当是对象.aa但是没有调用哦
    call 函数,改变this指向并直接调用 fn.call(对象,参数1,参数2)   想用哪个方法就先找到哪个方法然后.call传入要处理的数据和参数
    apply 就是对数组做处理的时候想想可不可以用已经存在的函数可以就用apply将数组当参数传入
    bind  不调用函数,用于定时器回调  事件处理函数 
    降低网页请求数量和请求资源的体积(压缩代码)

    继承: 
      原型继承,设置构造函数的prototype 为某一个父类对象  Student.prototype = new Person 或者Person的原型(这个会使得儿子添加方法父亲也有)
         缺点是无法设置构造函数的参数
      借用构造函数  在儿子中调用父亲函数并把this指向儿子对象 儿子构造中Person.call(this,name,age)
         缺点: 构造函数的方法根据我们分析应该写在原型对象里面,所以恰恰这种方法不能继承原型中的方法
      组合继承    前两种结合
   高阶函数: 函数作为参数或者作为返回值

   任务队列的代码只有等到其他顺序代码执行完毕才会执行
   对象的拷贝:
      浅拷贝: 遍历对象key 依次赋值  只能把对象的以一层属性拷贝,属性的属性是共享的
      深拷贝: 遍历对象key 如果属性值是对象,数组,递归拷贝
   遍历DOM树: 
      function bianli (parent){
         for(let i=0;i<parent.children.length;i++){
            let child = parent.children[i];
            bianli(child)
         }
      }
 * 
 * 
 * 










 
 */